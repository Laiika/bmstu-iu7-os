\setcounter{page}{2}

\chapter{Функции обработчика прерывания от системного таймера}

\section{Операционные системы семейства Unix}

По тику:

\begin{itemize}
	\item инкремент счетчика времени с момента запуска системы (SVR4);
	\item инкремент счетчика реального времени;
        \item инкремент счетчика процессорного времени, полученного процессом в режиме задачи и в режиме ядра;
	\item декремент кванта;
	\item декремент счетчиков времени отложенных вызовов, при достижении счетчиками нуля установка флага для обработчиков отложенных вызовов.
\end{itemize}

По главному тику:

\begin{itemize}
	\item инициализация отложенного вызова функции планировщика;
	\item инициализация отложенного вызова процедуры wakeup, которая меняет состояние процесса со <<спящего>> на <<готовый к выполнению>>;
	\item пробуждение системных процессов, таких как swapper;
	\item декремент счетчика времени, которое осталось до отправления одного из следующих сигналов:
	\begin{itemize}
		\item SIGALRM – сигнал, посылаемый процессу по истечении времени, заданного функцией alarm();
		\item SIGPROF –  сигнал, посылаемый процессу по истечении времени, заданного в таймере профилирования;
		\item SIGVTALRM –  сигнал, посылаемый процессу по истечении времени, заданного в <<виртуальном>> таймере.
	\end{itemize}
\end{itemize}

По кванту:
\begin{itemize}
        \item отправка сигнала SIGXCPU текущему процессу, если он превысил выделенную для него квоту процессорного времени.
\end{itemize}

\section{Операционные системы семейства Windows}

По тику:

\begin{itemize}
	\item инкремент счетчика реального времени;
	\item декремент кванта текущего потока;
	\item декремент счетчиков времени отложенных задач.
\end{itemize}

По главному тику:

\begin{itemize}
	\item инициализация диспетчера настройки баланса путем освобождения объекта <<событие>>, на котором он ожидает.
\end{itemize}

По кванту:

\begin{itemize}
	\item инициализация диспетчеризации потоков путем постановки соответствующего объекта в очередь DPC.
\end{itemize}


\chapter{Пересчет динамических приоритетов}

Системы семейств Unix и Windows являются системами разделения времени с динамическими приоритетами и вытеснением. Динамические приоритеты могут иметь только пользовательские процессы.

\section{ОС семейства Unix}

Очередь процессов, готовых к выполнению, формируется согласно приоритетам процессов и принципу вытесняющего циклического планирования, то есть сначала выполняются процессы, имеющие больший приоритет, а процессы с одинаковыми приоритетами выполняются циклически друг за другом в течение кванта времени. Если процесс с более высоким приоритетом поступает в очередь готовых к выполнению процессов, планировщик вытесняет текущий процесс и предоставляет ресурс более приоритетному процессу.

Приоритет задается целым числом от 0 до 127. Чем меньше число, тем выше приоритет процесса. Приоритеты от 0 до 49 зарезервированы ядром операционной системы, пользовательские процессы могут обладать приоритетом от 50 до 127.

Приоритеты пользовательских процессов могут изменяться во времени в зависимости от следующих факторов:

\begin{itemize}
	\item результат последнего измерения степени загруженности CPU процессом;
	\item фактор любезности: чем меньше его значение, тем выше приоритет процесса (только суперпользователь может поменять значение фактора с помощью системного вызова nice).
\end{itemize}

Дескриптор процесса proc содержит следующие поля, относящиеся к приоритету:

\begin{itemize}
	\item \textbf{p\_pri} --- текущий приоритет планирования;
        \item \textbf{p\_usrpri} --- приоритет процесса в режиме задачи;
        \item \textbf{p\_cpu} --- результат последнего измерения степени загруженности процессора процессом;
	\item \textbf{p\_nice} --- фактор любезности.
\end{itemize}

Планировщик использует значение \textbf{p\_pri} для принятия решения о том, какой процесс направить на выполнение. У процесса, который находится в режиме задачи, значения \textbf{p\_pri} и \textbf{p\_usrpri} равны. Значение  \textbf{p\_pri} может быть повышено планировщиком для выполнения процесса в режиме ядра. При этом \textbf{p\_usrpri} будет использоваться для хранения приоритета, который будет назначен процессу при возврате в режим задачи.

Ядро системы связывает приоритет сна с событием или ожидаемым ресурсом, из-за которого процесс может быть заблокирован. Когда процесс <<просыпается>>, ядро устанавливает в поле \textbf{p\_pri} значение приоритета сна, зависящее от события или ресурса, по которому произошла блокировка.

\FloatBarrier
\begin{table}[h]
    \begin{center}
        \begin{threeparttable}
        \captionsetup{justification=raggedright,singlelinecheck=off}
        \caption{Приоритеты сна в 4.3BSD}
        \label{tbl:bsd}
        \begin{tabular}{|c|c|c|}
            \hline
            Приоритет & Значение & Описание \\
            \hline
            PSWP & 0 & Свопинг \\ \hline  
            PSWP + 1 & 1 & Страничный демон \\ \hline
            PSWP + 1/2/4 & 1/2/4 & Другие действия при обработке памяти \\ \hline
            PINOD & 10 & Ожидание освобождения inode  \\ \hline 
            PRIBIO & 20 & Ожидание дискового ввода-вывода \\ \hline
            PRIBIO + 1 & 21 & Ожидание освобождения буфера \\ \hline
            PZERO & 25 & Базовый приоритет \\ \hline
            TTIPRI & 28 & Ожидание ввода с терминала \\ \hline
            TTORPI & 29 & Ожидание вывода с терминала \\ \hline
            PWAIT & 30 & Ожидание завершения процесса потомка \\ \hline
            PLOCK & 35 & $\begin{array}{cccc}
            	$Консультативное ожидание$ \\
            	$блокированного ресурса$
            \end{array} $   \\ \hline
            PSLEP & 40 & Ожидание сигнала \\ \hline                                             
		\end{tabular}
        \end{threeparttable}
    \end{center}
\end{table}
\FloatBarrier

Системы разделения времени пытаются выделить процессорное время так, чтобы конкурирующие процессы получили его примерно в равных количествах. 
Такой подход требует слежения за использованием процессора каждым из процессов. 
При инициализации процесса поле \textbf{p\_cpu} равно нулю. На каждом тике обработчик прерывания увеличивает \textbf{p\_cpu} текущего процесса на единицу, вплоть до максимального значения --- 127. Каждую секунду обработчик прерывания инициализирует отложенный вызов процедуры schedcpu(), которая уменьшает значение \textbf{p\_pri} каждого процесса исходя из фактора <<полураспада>>, который вычисляется по формуле \eqref{for:bsd}.

\begin{equation}
    \label{for:bsd}
    decay = \frac{2 \cdot load\_average}{2 \cdot load\_average + 1}
\end{equation}

где \textit{load\_average} - это среднее количество процессов, находящихся в состоянии готовности к выполнению, за последнюю секунду.

Кроме того, процедура schedcpu() пересчитывает приоритеты для режима задачи всех процессов по формуле \eqref{for:task}.

\begin{equation}
    \label{for:task}
    p\_usrpri = PUSER + \frac{p\_cpu}{2} + 2 \cdot p\_nice
\end{equation}

где \textit{PUSER} - базовый приоритет в режиме задачи, равный 50.

В результате \textbf{p\_cpu} будет увеличен, если процесс до вытеснения другим процессом использовал большое количество процессорного времени. Это приведет к росту значения \textbf{p\_usrpri}, из чего следует понижение приоритета. Чем дольше процесс простаивает в очереди на выполнение, тем больше фактор
полураспада уменьшает его \textbf{p\_cpu}. Такая схема предотвращает бесконечное откладывание низкоприоритетных процессов в ОС.

\section{ОС семейства Windows}

В Windows процессу при создании назначается приоритет. Потоку назначается приоритет относительно приоритета процесса. В Windows реализовано вытесняющее планирование на основе уровней приоритета: если поток с более высоким приоритетом становится готовым к выполнению, поток с более низким приоритетом вытесняется планировщиком, даже если квант текущего не истек. По истечению кванта времени текущего потока, ресурс передается самому приоритетному потоку в очереди готовых к выполнению.

В Windows есть диспетчер настройки баланса, который раз в секунду сканирует очередь готовых потоков. Если обнаружены потоки, ожидающие выполнения более 4 секунд, диспетчер повышает их приоритет до 15. Когда истекает квант, приоритет потока снижается до базового приоритета. Если поток не был завершен за квант времени или был вытеснен потоком с более высоким приоритетом, то после снижения приоритета поток возвращается в очередь.

Для того, чтобы минимизировать расход процессорного времени, диспетчер настройки баланса сканирует только 16 позиций в очереди и повышает приоритет не более чем у 10 потоков за один проход. При обнаружении 10 потоков, приоритет которых следует повысить, диспетчер настройки баланса прекращает сканирование. При следующем проходе сканирование возобновляется с того места, где оно было прервано.

В Windows используется 32 уровня приоритета:
\begin{itemize}
    \item от 0 до 15 - динамические уровни (уровень 0 зарезервирован для потока обнуления страниц);
    \item от 16 до 31 - приоритеты процессов реального времени (31 --- наивысший).
\end{itemize}

Уровни приоритета потоков назначаются с двух позиций: Windows API и ядра ОС.

Сначала Windows API сортирует процессы по классу приоритета, которые были назначены при их создании:

\begin{itemize}
    \item реального времени (Real-time) (4) ;
    \item высокий (High) (3);
    \item выше обычного (Above Normal) (6);
    \item обычный (Normal) (2);
    \item ниже обычного (Below Normal) (5)
    \item простой (Idle) (1).
\end{itemize}

Затем назначается относительный приоритет потоков процесса:

\begin{itemize}
    \item критичный по времени (Time-critical) (15) ;
    \item наивысший (Highest) (2);
    \item выше обычного (Above-normal) (1);
    \item обычный (Normal) (0);
    \item ниже обычного (Below-normal) (-1);
    \item низший (Lowest) (-2);
    \item простой (Idle) (-15).
\end{itemize}

Исходный базовый приоритет потока наследуется от базового приоритета процесса. 
Процесс по умолчанию наследует свой базовый приоритет у того процесса, который его создал. 

В таблице \ref{tbl:prioritet} показано соответствие между приоритетами Windows API и ядра системы.

\FloatBarrier
\begin{table}[h]
	\begin{center}
        \begin{threeparttable} \captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:prioritet} Соответствие между приоритетами Windows API и ядра Windows}
		\begin{tabular}{|c|c|c|c|c|c|c|}
            \hline
            Класс приоритета & Real-time & High & Above &
            Normal & Below Normal & Idle \\ \hline
            Time Critical & 31 & 15 & 15 & 15 & 15 & 15 \\ \hline
            Highest & 26 & 15 & 12 & 10 & 8 & 6 \\ \hline
            Above Normal & 25 & 14 & 11 & 9 & 7 & 5 \\ \hline
            Normal & 24 & 13 & 10 & 8 & 6 & 4 \\ \hline
            Below Normal & 23 & 12 & 9 & 7 & 5 & 3 \\ \hline
            Lowest & 22 & 11 & 8 & 6 & 4 & 2 \\ \hline
            Idle & 16 & 1 & 1 & 1 & 1 & 1 \\ \hline
		\end{tabular}
        \end{threeparttable}
	\end{center}
\end{table}
\FloatBarrier

Планировщик может повысить текущий приоритет потока в динамическом диапазоне (от 1 до 15) по следующим причинам:

\begin{itemize}
\item завершение операций ввода/вывода (таблица \ref{tbl:input-output});

\FloatBarrier
\begin{table}[h]
	\begin{center}
        \begin{threeparttable} \captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:input-output} Рекомендуемые значения повышения приоритета}
		\begin{tabular}{|l|c|}
            \hline
            \textbf{Устройство} & \textbf{Приращение} \\\hline
            Диск, CD-ROM, параллельный порт, видео & 1 \\ \hline
            Сеть, почтовый ящик, именованный канал, & 2 \\
            последовательный порт & \\ \hline
            Клавиатура, мышь & 6 \\ \hline
            Звуковая плата & 8 \\ \hline
		\end{tabular}
        \end{threeparttable}
	\end{center}
\end{table}
\FloatBarrier
    \item повышение вследствие событий планировщика или диспетчера;
    \item повышение приоритета владельца блокировки;
    \item ввод из пользовательского интерфейса;
    \item длительное ожидание ресурса исполняющей системы;
    \item ожидание объекта ядра;
    \item готовый к выполнению поток не был запущен в течение длительного времени;
    \item повышение приоритета службой планировщика MMCSS.
\end{itemize}

\subsection{MMCSS}

Потоки, на которых выполняются различные мультимедийные приложения должны выполняться с минимальными задержками. В Windows драйвер MMCSS (\textit{MultiMedia Class Scheduler Service}) временно повышает приоритет таких потоков. 

Одно из наиболее важных свойств для планирования потоков --- категория планирования, определяющия приоритет потоков, зарегестрированных в MMCSS (таблица \ref{tbl:category}). Функции MMCSS временно повышают приоритет потоков до уровня, соответствующего их категориям планирования. Затем их приоритет снижается до уровня, соответствующего категории Exhausted для того, чтобы другие потоки могли получить ресурс.

\FloatBarrier
\begin{table}[h]
	\begin{center}
        \begin{threeparttable} \captionsetup{justification=raggedright,singlelinecheck=off}
		\caption{\label{tbl:category} Категории планирования}
		\begin{tabular}{|p{40mm}|p{30mm}|p{80mm}|}
            \hline
            \textbf{Категория} & \textbf{Приоритет} & \textbf{Описание} \\
            \hline
            High & 23-26 & Потоки профессионального аудио (Pro
Audio), запущенные с приоритетом выше, чем у других потоков на системе, за
исключением критических системных потоков \\
            \hline
            Medium & 16-22 & Потоки, являющиеся частью приложений
первого плана, например Windows Media Player \\
            \hline
            Low & 8-15 & Все остальные потоки, не являющиеся частью
предыдущих категорий \\
            \hline
            Exhausted & 1-7 & Потоки, исчерпавшие свою
долю времени центрального процессора, выполнение которых продолжиться, только
если не будут готовы к выполнению другие потоки с более высоким уровнем
приоритета \\
            \hline
		\end{tabular}
        \end{threeparttable}
	\end{center}
\end{table}
\FloatBarrier


\subsection{IRQL}

Хотя контроллеры прерываний устанавливают приоритетность прерываний,
Windows устанавливает свою собственную схему приоритетности прерываний, известную как уровни запросов прерываний (IRQL). В ядре IRQL---уровни представлены в виде номеров от 0 до 31 на системах x86, где более высоким номерам соответствуют прерывания с более высоким приоритетом.

Прерывания обслуживаются в порядке их приоритета, и прерывания с более
высоким уровнем приоритета получают преимущество в обслуживании. При
возникновении прерывания с высоким уровнем приоритета процессор сохраняет состояние прерванного потока и запускает связанный с прерыванием диспетчер системных прерываний. Тот, в свою очередь, поднимает IRQL и вызывает процедуру
обработки прерывания. После выполнения этой процедуры диспетчер прерываний понижает IRQL-уровень процессора до значения, на котором он был до возникновения прерывания, а затем загружает сохраненное состояние машины.
Прерванный поток продолжает выполнение с того места, в котором оно было
прервано.

На рис. \ref{img:irql} показаны IRQL-уровни для архитектуры x86.
\imgScale{0.35}{irql}{Уровни запросов прерываний}
\FloatBarrier


\chapter*{Вывод}
\addcontentsline{toc}{chapter}{Вывод}

 ОС семейств Unix и Windows --- системы разделения времени с динамическими приоритетами и вытеснением, поэтому обработчик прерывания от системного таймера в этих системах выполняет схожие функции:
\begin{itemize}
	\item инкремент счетчиков тиков;
	\item декремент кванта;
	\item инициализация отложенных действий, которые относятся к работе планировщика, например, пересчет приоритетов.
\end{itemize}

Пересчет динамических приоритетов осуществляется только для пользовательских процессов, чтобы избежать бесконечного откладывания.


