ЛАБА 1

Любая операционная система работает под управлением прерывания. Прерываие - движок ОС. В совр ОП система прерываний, принято выделять 3 типа прерываний:
1) системные вызовы system call (буквально, вызов системы) - программные прерывания (прерывание программы) API (определённый набор) (спец. POSIX)
2) исключительные ситуации (исключения)
3) аппаратные прерывания (от аппаратуры) (если видим interapted)
Группы ап.Пр.:
1) прерывания от системного таймера ("таймер") (единственное периодическое прерываие в системе) (в досе 1 раз в секунду) DOS: 18 и 2 десятых в секунду уложатся гГЦ
2) прерывания от внешних устройств (информируют процессор о завершении опрерации ввода-вывода (их оч много)) (внУстр: монитор и внешн. карточка)
РЕГИСТРЫ ПРОЦЕССОРЫ - неотъемлемая часть процессора (не память)
memery mapping (отображение) (MOV, команды работы с памятью)
input/output mapping (IN/OUT, порты ввода/вывода, порт - это адрес. минимальный порт (усл. назв.) - байт)
2 АП:
1) оперативной памяти
2) портов ввода/вывода (контроллера прерываний и ; в порты посылается команда)
2) от действия оператора

ctrl+c завершение процессов

/Признак времени/

тактовый генератор (гГц) - _П_П_П_ (делители и линии задержки) _l_l_l_l_ (тики) (приходит импульс на контроллер прерывания (не прийти не может) (ничто не может его отменить))
=> вектор прерывания, используется системой для получения адреса обработчика Прер в досе по таблице векторов прерывания. 
начинается с 0го адреса, 256 байт, 4 байт адрес (2Б сегмент, 2, far-адрес)
когда вызывается обработчик прерывания? по тику (18,2 раза в секунду int 8h вызывается по тику, а не мы вызываем, система переходит по известному адресу на выполнение обработчика прерывания) (система не может перейти по неизвестному адресу)

ЛАБА1.
windowsXP, 32. Доступен режим симуляции DOSа. (в DosBox обработчик не достанем - проверить)
Что-то вскроем.
Sourcer (sr.exe) сможем получить листинг обработчика int 8H. Переведёт машинный код в ассемблер. (какие-то интегральные схемы, intel8086)
(продавать компы с установленной системой DOS => популярность систем, ПК 8086 10 лет - очень много, microsoft не раскрывает коды своих систем) (резидентные программы - появилось в DOSе)
ДизАссемблировать V86 режим эмуляции DOSа
в Sourcerе указать begginning adress end ещё чёт, всякие адреса. В листинге 4 столбца: 
адреса типа (сегмент смещения)  |  команда в 16ичном формате  |  эквивалентная команды на ассемблере  |  комментарий
получаем таблицу векторов прерываний, 4 байт памяти. Конечный адресс = начальный + сколько может занимать что-то в ТП. 
прерывание заканчивается командой IRET (interapted return) (+ ОТЛИЧИЕ ОТ RET!!)
JUMP -> IRET (IRET и его адрес указать в листинге) (нет инфы, что делается в этом участке кода)

ФУНКЦИИ обработчика 8го прерывания:
1) инкремент счётчика реального времени (инкрементирует реальное время, которое показывает комп ) (в оперативной памяти по известному адреса BIOS)
(таблетка - аккумуляторная микроСхема. CMOS микросхема - пичитать в вики (для времени служит)) (ведение счетчика времени, содержимое счётка копируется в BIOS при включении, чтобы обращаться к оперативной памяти)
2) декремент времени до отключения моторчика дисковода (винчестера не было, информация считывалась с флопиков)
(считывание с массива -> цикл с предусловием (for), while) (раскрутить диск до определённой скорости, чтобы считать. Винчестер вообще не останавливался)
(непроизводительные затраты времени ("долго"), чтобы не происходило - функ выключения возложена на таймер, это отложенное действие; могут инициироваться на обработчик системного таймера)
(команды посылается на контролер дисковода)
3) вызов пользовательского прерывания 1Ch (microSoft разработала) (оперативная память - 1 мб: ОС и программа приложения, которое выполняется) (одна единственная исполняемая программа) (Питер Нортен, Нортен-команды) (1Ch (это заглушка) чтобы разработчики не вешались на 8е прерывание. Почему не стоит вешаться? если повесить слишком много не прерывание, оно будет выполняться дольше) (но большинство резидентов на int 8h)

НАСЧЁТ ЛАБЫ:
Получив листинг, построить схему алгоритма.
СХЕМА АЛГОРИТМА - не блок-схема (по ГОСТу)
sub1/ sub2/ ... (subroutine - классическое название подпрограммы) (так же надо дизАссемблировать)

2 листинга, 2 схемы (8е прерывание, субратина (запрещает прерывание, но там есть ветвление))
отчёт сдаётся в бумажном виде.
в алгоритме показать каждую команду. Если решают одну команду - смотреть по смыслу.
Префиксная команда lock (перед какой командой стоит, делает следующую код=манду неделимой (то есть прервать нельзя). Почему стоит lock и почему именно перед ней?)



ЛАБА 2
Концептуальная схема.
Была реализована идея распараллеливания. Канальная программа, в рез вып кот управляет внеш устр. Упр-е передано спец устр - каналу. Появление в системах 3го поколения - полноценной системы прерываний, которая имеется во всех современных системах.
Шинная архитектура в совр комп. В шинной арх работа вн уст упр контроллеры - спеу прогг устройства. Контроллеры и адаптеры. Конт входят в состав внешнего устройства, адаптеры - на материнской плате.
контролллер - прог-упр устройство, получает команду от  процессора и упр вн устр.
Сигналы 3х типов (каждый сигнал по отдельной шине):
1) данные
--- команды
--- данные
2) адреса
3) сигналы управления

шина данных---------------------------^-----------^---------------
                              	      |           | 
шина адресов-----------------------^--|---------|-|---------------
                           	   |  |         | |
шина управления-----------------^--|--|-------^-|-|---------------
                        	|  |  |       | | |
                        	|  |  |       | | |
                        	|  |  |       | | |
                      		V  |  V       | V V
                  	       процессор      О З У


{дописать схему выше}
{вставить текст}

interupt request (ножки)
1. на irq0 приходит ток
2. на irq1 приходит прерывание от клавы ps/2
3. на irq2 приходит прерывание от мыши ps/2 

{вставить текст}

в конце цикла вып кажд команды процессор проверяет налич сигнала на ножке. 
-> выборка -> дешифрация -> выполнение -> [провряется и проверяется]
посылает int A, если прошёл сигнал.
Получив сигнал контроллер выставляет на шину данных вектор прерывания. Процессор получает по шине данных этот вектор, и в DOSе 
Этот вектор используется как смещение, к вектору прерывания в таблице ВП.
Получив В, процессор переходит по адресу прер, и нач вып обработчик прерывания. 
При этом выполнение к-л прог-ы прерывается и для того чтобы восстановить выполнение, необходимо запомнить содержимое рег проц, чтобы затем их восстановить для продолжение прер работы - сохраанение аппаратного контекста. Сначала он сохр, потом восстанавл.
MSI - message signal interrupt. В совр системах "умное железо" - управляется nanoПрограммой.

{вставить текст}

Как формир ВП? базовый вектор + номер irq (в реальном режиме = 8 (8 + 0 = 8 => int 8h))
(8 + 1 = 9 => int 9h - прерывание от клавы)
5f - fffff - 2^20 = 1мб = 1024кб = fffff (в 16разр max FFFF, но шина 20разр => FFFFF)
(в DOSе (в регистре) не возможно из 16р в 20р => используется смещение)

В нач ОП (обраб прер), 4 push. Это сохранение содержания регистров процессора, так как прерывание (от сист таймера - наивысш приор; прерыв любую работу). 
в ОС разделение времени, квантуется, огромная частота. В сист разд врем основное времня - декремент кванта (проимходит основная задача).
однояд: В памяти одна единственная прог (опер сист и приложение)

{схема такая вытянутая палка}

{вставить текст}

Машины с архитектурой Фон Неймана. Комп работает по программе. ассемблер - мненоническое представление машинного кода. 
В компьбтере всё адресуется, всё выполняется по адресу. Всё это машинные команды (-> ассемблерный код).
FortRun4? (много goto, трехместный оператор if, пакетный режим, программа-спагетти цветными карандашами)
Pascal - Николаус Вирт - обучение структурному прогр.
"Программист - свободен от языка" (алгоритмизация) (нарисованный структурированный алгоритм => напишем на любом ЯП)
Паскаль - if then else (бред, но на Паскале) (убогий и ущербный)
С - мощнейший, структурированный (не надо go, поддерживает if, написание функций)
Следование, ветвление, повторение. Как правильно рисовать вложенные if?
В прер от таймера не может быть цикла, но мб вложенный if.

ВЛОЖЕННЫЕ IF.

{схема if then else}

"нет в if - пишут только лохи", и никаких закруглений (ГОСТ)
Все элементы примерно одного размера. алгоритм не рисуется для того, чтобы указать все действия в рограмме. показать условные переходы - ifы, вложения, циклы.
"СХЕМА АЛГОРИТМА ГОСТ" - google

{схема предусловие}

ОТЧЁТЫ
листинг (8е IRET)
(субратина)
их схемы
абсолютно полный алгоритм, отображающий все действия в обработчика
вложенный if
цикла в ОП быть не может (должны заканчиваться как можно быстрей (приоретет), только ветвления)
содерж счёт = 0 => сброс или включение флага моторчика дисковода
команды посылки в порт команды
установить в регистре порт, затем  послать команду
один элемент, одно действие.
устанавливаемые влаги, по которым идёт ветвение. 







